| **_Feature_**     | **_Array_**                                                              | **_LinkedList_**                                                                                                                               |
|-------------------|--------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------|
| Structure         | 	Contiguous block of memory elements                                     | Sequence of nodes where each node points to the next.                                                                                          |
| Size              | Fixed size (static arrays) or dynamic resizing needed.                   | Dynamic size; can easily grow or shrink.                                                                                                       |
| Memory Usage      | Efficient memory usage                                                   | Extra memory required to store pointers                                                                                                        |
| Access Time       | O(1) random access to elements using index                               | O(n) access time, must traverse the head                                                                                                       |
| Insertion         | At End O(1) in the middle O(n)                                           | If tail then O(1) at beginning and end, middle O(n)locate the node and the O(1) to insert                                                      |
| Deletion          | From End: O(1) - From Beginning or Middle: O(n) due to shifting elements | From Begining: O(1) - From End: O(n) unless tail and previous pointer are maintained, in middle: O(n) to locate the node, then O(1) to delete. |
| Search            | - Unsorted: O(n) - Sorted: (log n) with binary search                    | O(n) regardless sorted or not.                                                                                                                 |
| Cache Performance | Better due to locality of reference                                      | poorer because nodes scattered in memory                                                                                                       |
| Flexibility       | Less Flexible in size; resizing can be costly                            | More flexible; easy to insert or remove nodes                                                                                                  |
| Use Cases         | When frequent access is required -suitable or rarely changing data       | When frequent insertion and deletion operation are needed. Suitable for dynamic data structures like queues and stacks                         |
| Traversal         | Index Bases                                                              | Requires traversal from the head.                                                                                                              |
   
